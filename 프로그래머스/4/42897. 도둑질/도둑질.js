/*
문제 정리
각각 떨어진 집을 털어서 얻을 수 있는 돈의 최댓값 구하기

DP의 5단계
1) 하위 문제 정의
2) 해 일부분 추측
3) 하위 문제와 해 연결
4) 알고리즘 구성
5) 원래 문제와 비교

DP문제를 해결하기 위해서는 위의 5가지 단계를 따르면 보다 간단하게 해결할 수 있다.
5가지 단계는 순차적인 단계가 아니므로 해의 일부분을 먼저 추측하고 나머지 단계들을 살펴볼 것이다.

추측
문제를 해결하기 위해서 알아야 할 일부분의 해는 무엇일까 ?
문제에서는 money의 최댓값을 얻기 위해 모든 집을 확인해 보아야 한다.
그러기 위해서 집에 방문했을 경우 해당 집을 털지 털지 않을지 결정해야 한다.

하위 문제 정의
하위 문제는 해당 집을 털었을 때의 최적해와 털지 않았을 때의 최적해를 구하는 것이다.
모든 집을 중복 없이 1번씩 방문하므로 하위 문제의 개수 = n이다.

하위 문제와 해 연결(점화식 구성)
배열을 처음부터 순차적(위상적 순서)으로 방문했을 때, 해당 집의 위치에서 money의 최대값을 DP에 담는다.
이를 점화식으로 표현하면 다음과 같다.
DP[i] = Math.max(DP[i - 1], DP[i] + DP[i - 2]) i = 0... n - 1

점화식에 대해 설명을 추가하자면, DP[i - 1]은 해당 집을 털 지 않았을 경우의 최댓값이고,
DP[i] + DP[i - 2]의 경우 해당 집을 털기로 결정했을 경우 바로 이전 집은 인접한 집이라 못털기 때문에 2칸 뒤의 집의 money 최댓값과 더해준다.

하위 문제당 연산 시간은 배열을 index를 통해 접근(O(1))과 간단한 연산으로 구성되어 있으므로 상수시간에 해결 가능하다.
그러므로 총 연산 시간은 하위 문제의 개수O(n)와 하위 문제의 연산 시간O(1)을 곱하여 O(n)의 시간을 얻을 수 있다.

알고리즘 구현(조건 검증)
알고리즘은 상향식(반복문), 하향식(재귀 & 메모이제이션) 두 가지로 구성할 수 있다.
문제에서는 처음 집부터 순차적으로 방문해나갈 것이므로 상향식으로 구현한다.
또한, 해당 알고리즘이 무한으로 반복되는 경우를 방지하기 위해서 비순환적, 위상적 순서를 만족하는지 살펴보아야 한다.

해당 문제에서 data는 배열로 주어지지만, 개념적으로는 원으로 이루어진 집이기 때문에 문제에서는 DP배열 2개를 만들어서 진행할 것이다.
2개를 만드는 이유는 처음 집과 마지막 집을 동시에 방문하는 경우를 방지해주기 위해서이다.
때문에 처음 집을 방문하는 경우에는 마지막 집을 0으로 처리해주고,
마지막 집을 방문하는 경우에는 처음 집을 0으로 처리해준다.

원래 문제와 연결
문제에서는 원래 문제의 각 집들에 대해 해당 위치에서의 money의 최댓값을 구하므로,
결국 마지막 집에 도착하게 되면 문제에서 원하던 money의 최댓값을 얻을 수 있다.
*/
function solution(money) {
    if (money.length <= 3) {
        return Math.max(...money)
    }
    
    // 첫 번째 집 턴 경우 마지막 집 0 처리
    const DP1 = money.slice()
    DP1.unshift(0)
    DP1[DP1.length - 1] = 0
    // 마지막 집 턴 경우 첫 번째 집 0 처리
    const DP2 = money.slice()
    DP2.push(0)
    DP2[0] = 0
    for(let i = 2; i < money.length + 1; i ++) {
        DP1[i] = Math.max(DP1[i - 1], DP1[i] + DP1[i - 2])
        DP2[i] = Math.max(DP2[i - 1], DP2[i] + DP2[i - 2])
    }
    
    return Math.max(DP1[DP1.length - 1], DP2[DP2.length - 1])
}